import {
  cloneVNode,
  computed,
  defineComponent,
  getCurrentInstance,
  h,
  inject,
  onBeforeUnmount,
  onMounted,
  onUnmounted,
  onUpdated,
  provide,
  reactive,
  ref,
  shallowReactive,
  useId,
  watch,
  watchEffect
} from "./chunk-U3LI7FBV.js";
import "./chunk-BUSYA2B4.js";

// node_modules/vue3-carousel/dist/carousel.mjs
var injectCarousel = Symbol("carousel");
var SNAP_ALIGN_OPTIONS = [
  "center",
  "start",
  "end",
  "center-even",
  "center-odd"
];
var SLIDE_EFFECTS = ["slide", "fade"];
var BREAKPOINT_MODE_OPTIONS = ["viewport", "carousel"];
var DIR_OPTIONS = [
  "ltr",
  "left-to-right",
  "rtl",
  "right-to-left",
  "ttb",
  "top-to-bottom",
  "btt",
  "bottom-to-top"
];
var I18N_DEFAULT_CONFIG = {
  ariaNextSlide: "Navigate to next slide",
  ariaPreviousSlide: "Navigate to previous slide",
  ariaNavigateToSlide: "Navigate to slide {slideNumber}",
  ariaNavigateToPage: "Navigate to page {slideNumber}",
  ariaGallery: "Gallery",
  itemXofY: "Item {currentSlide} of {slidesCount}",
  iconArrowUp: "Arrow pointing upwards",
  iconArrowDown: "Arrow pointing downwards",
  iconArrowRight: "Arrow pointing to the right",
  iconArrowLeft: "Arrow pointing to the left"
};
var DIR_MAP = {
  "left-to-right": "ltr",
  "right-to-left": "rtl",
  "top-to-bottom": "ttb",
  "bottom-to-top": "btt"
};
var NORMALIZED_DIR_OPTIONS = Object.values(DIR_MAP);
var DEFAULT_CONFIG = {
  enabled: true,
  itemsToShow: 1,
  itemsToScroll: 1,
  modelValue: 0,
  transition: 300,
  autoplay: 0,
  gap: 0,
  height: "auto",
  wrapAround: false,
  pauseAutoplayOnHover: false,
  mouseDrag: true,
  touchDrag: true,
  snapAlign: SNAP_ALIGN_OPTIONS[0],
  dir: DIR_OPTIONS[0],
  breakpointMode: BREAKPOINT_MODE_OPTIONS[0],
  breakpoints: void 0,
  i18n: I18N_DEFAULT_CONFIG,
  ignoreAnimations: false,
  slideEffect: SLIDE_EFFECTS[0]
};
var createSlideRegistry = (emit) => {
  const slides = shallowReactive([]);
  const clonedSlides = shallowReactive([]);
  const updateSlideIndexes = (startIndex) => {
    if (startIndex !== void 0) {
      slides.slice(startIndex).forEach((slide, offset) => {
        var _a;
        (_a = slide.exposed) === null || _a === void 0 ? void 0 : _a.setIndex(startIndex + offset);
      });
    } else {
      slides.forEach((slide, index) => {
        var _a;
        (_a = slide.exposed) === null || _a === void 0 ? void 0 : _a.setIndex(index);
      });
    }
  };
  return {
    registerSlide: (slide, index) => {
      if (!slide)
        return;
      if (slide.props.isClone) {
        clonedSlides.push(slide);
        return;
      }
      const slideIndex = index !== null && index !== void 0 ? index : slides.length;
      slides.splice(slideIndex, 0, slide);
      updateSlideIndexes(slideIndex);
      emit("slide-registered", { slide, index: slideIndex });
    },
    unregisterSlide: (slide) => {
      const slideIndex = slides.indexOf(slide);
      if (slideIndex === -1)
        return;
      emit("slide-unregistered", { slide, index: slideIndex });
      slides.splice(slideIndex, 1);
      updateSlideIndexes(slideIndex);
    },
    cleanup: () => {
      slides.splice(0, slides.length);
    },
    getSlides: () => slides,
    getClonedSlides: () => clonedSlides
  };
};
function getNumberInRange({ val, max, min }) {
  if (max < min) {
    return val;
  }
  return Math.min(Math.max(val, isNaN(min) ? val : min), isNaN(max) ? val : max);
}
var calculateOffset = (snapAlign, itemsToShow) => {
  switch (snapAlign) {
    default:
    case "start":
      return 0;
    case "center":
      return (itemsToShow - 1) / 2;
    case "center-odd":
      return (itemsToShow - 1) / 2;
    case "center-even":
      return (itemsToShow - 2) / 2;
    case "end":
      return itemsToShow - 1;
  }
};
function getScrolledIndex({ config, currentSlide, slidesCount }) {
  const { snapAlign = "center", wrapAround, itemsToShow = 1 } = config;
  const offset = calculateOffset(snapAlign, itemsToShow);
  if (wrapAround) {
    return currentSlide - offset;
  }
  return getNumberInRange({
    val: currentSlide - offset,
    max: slidesCount - itemsToShow,
    min: 0
  });
}
function getMinSlideIndex({ config, slidesCount }) {
  const { snapAlign = "center", wrapAround, itemsToShow = 1 } = config;
  if (wrapAround || itemsToShow > slidesCount) {
    return 0;
  }
  return Math.max(0, Math.floor(calculateOffset(snapAlign, itemsToShow)));
}
function getMaxSlideIndex({ config, slidesCount }) {
  const { snapAlign = "center", wrapAround, itemsToShow = 1 } = config;
  function snapAlignCalculations() {
    switch (wrapAround ? "" : snapAlign) {
      case "start":
        return Math.ceil(slidesCount - itemsToShow);
      case "center":
      case "center-odd":
        return slidesCount - Math.ceil((itemsToShow - 0.5) / 2);
      case "center-even":
        return slidesCount - Math.ceil(itemsToShow / 2);
      case "end":
      default:
        return Math.ceil(slidesCount - 1);
    }
  }
  return Math.max(snapAlignCalculations(), 0);
}
function mapNumberToRange({ val, max, min = 0 }) {
  const mod = max - min + 1;
  return ((val - min) % mod + mod) % mod + min;
}
function i18nFormatter(string = "", values = {}) {
  return Object.entries(values).reduce((acc, [key, value]) => acc.replace(`{${key}}`, String(value)), string);
}
function throttle(fn, ms = 0) {
  let isThrottled = false;
  let start = 0;
  let frameId = null;
  function throttled(...args) {
    if (isThrottled)
      return;
    isThrottled = true;
    const step = () => {
      frameId = requestAnimationFrame((time) => {
        const elapsed = time - start;
        if (elapsed > ms) {
          start = time;
          fn(...args);
          isThrottled = false;
        } else {
          step();
        }
      });
    };
    step();
  }
  throttled.cancel = () => {
    if (frameId) {
      cancelAnimationFrame(frameId);
      frameId = null;
      isThrottled = false;
    }
  };
  return throttled;
}
function except(obj, keys) {
  return Object.keys(obj).filter((k) => !keys.includes(k)).reduce((acc, key) => (acc[key] = obj[key], acc), {});
}
function getTransformValues(el) {
  const { transform } = window.getComputedStyle(el);
  return transform.split(/[(,)]/).slice(1, -1).map((v) => parseFloat(v));
}
function createCloneSlides({ slides, position, toShow }) {
  const clones = [];
  const isBefore = position === "before";
  const start = isBefore ? -toShow : 0;
  const end = isBefore ? 0 : toShow;
  if (slides.length <= 0) {
    return clones;
  }
  for (let i = start; i < end; i++) {
    const index = isBefore ? i : i + slides.length;
    const props = {
      index,
      isClone: true,
      id: void 0,
      // Make sure we don't duplicate the id which would be invalid html
      key: `clone-${position}-${i}`
    };
    const vnode = slides[(i % slides.length + slides.length) % slides.length].vnode;
    const clone = cloneVNode(vnode, props);
    clone.el = null;
    clones.push(clone);
  }
  return clones;
}
var FOCUSABLE_ELEMENTS_SELECTOR = 'a[href], button, input, textarea, select, details, [tabindex]:not([tabindex="-1"])';
function disableChildrenTabbing(node) {
  if (!node.el || !(node.el instanceof Element)) {
    return;
  }
  const elements = node.el.querySelectorAll(FOCUSABLE_ELEMENTS_SELECTOR);
  for (const el of elements) {
    if (el instanceof HTMLElement && !el.hasAttribute("disabled") && el.getAttribute("aria-hidden") !== "true") {
      el.setAttribute("tabindex", "-1");
    }
  }
}
function getDraggedSlidesCount(params) {
  const { isVertical, isReversed, dragged, effectiveSlideSize } = params;
  const dragValue = isVertical ? dragged.y : dragged.x;
  if (dragValue === 0)
    return 0;
  const slidesDragged = Math.round(dragValue / effectiveSlideSize);
  return isReversed ? slidesDragged : -slidesDragged;
}
var ARIA = defineComponent({
  name: "CarouselAria",
  setup() {
    const carousel = inject(injectCarousel);
    if (!carousel) {
      return () => "";
    }
    return () => h("div", {
      class: ["carousel__liveregion", "carousel__sr-only"],
      "aria-live": "polite",
      "aria-atomic": "true"
    }, i18nFormatter(carousel.config.i18n["itemXofY"], {
      currentSlide: carousel.currentSlide + 1,
      slidesCount: carousel.slidesCount
    }));
  }
});
var carouselProps = {
  // enable/disable the carousel component
  enabled: {
    default: DEFAULT_CONFIG.enabled,
    type: Boolean
  },
  // count of items to showed per view
  itemsToShow: {
    default: DEFAULT_CONFIG.itemsToShow,
    type: Number
  },
  // count of items to be scrolled
  itemsToScroll: {
    default: DEFAULT_CONFIG.itemsToScroll,
    type: Number
  },
  // control infinite scrolling mode
  wrapAround: {
    default: DEFAULT_CONFIG.wrapAround,
    type: Boolean
  },
  // control the gap between slides
  gap: {
    default: DEFAULT_CONFIG.gap,
    type: Number
  },
  // control the gap between slides
  height: {
    default: DEFAULT_CONFIG.height,
    type: [Number, String]
  },
  // control snap position alignment
  snapAlign: {
    default: DEFAULT_CONFIG.snapAlign,
    validator(value) {
      return SNAP_ALIGN_OPTIONS.includes(value);
    }
  },
  // sliding transition time in ms
  transition: {
    default: DEFAULT_CONFIG.transition,
    type: Number
  },
  // controls the breakpoint mode relative to the carousel container or the viewport
  breakpointMode: {
    default: DEFAULT_CONFIG.breakpointMode,
    validator(value) {
      return BREAKPOINT_MODE_OPTIONS.includes(value);
    }
  },
  // an object to store breakpoints
  breakpoints: {
    default: DEFAULT_CONFIG.breakpoints,
    type: Object
  },
  // time to auto advance slides in ms
  autoplay: {
    default: DEFAULT_CONFIG.autoplay,
    type: Number
  },
  // pause autoplay when mouse hover over the carousel
  pauseAutoplayOnHover: {
    default: DEFAULT_CONFIG.pauseAutoplayOnHover,
    type: Boolean
  },
  // slide number number of initial slide
  modelValue: {
    default: void 0,
    type: Number
  },
  // toggle mouse dragging.
  mouseDrag: {
    default: DEFAULT_CONFIG.mouseDrag,
    type: Boolean
  },
  // toggle mouse dragging.
  touchDrag: {
    default: DEFAULT_CONFIG.touchDrag,
    type: Boolean
  },
  // control snap position alignment
  dir: {
    type: String,
    default: DEFAULT_CONFIG.dir,
    validator(value) {
      return DIR_OPTIONS.includes(value);
    }
  },
  // aria-labels and additional text labels
  i18n: {
    default: DEFAULT_CONFIG.i18n,
    type: Object
  },
  ignoreAnimations: {
    default: false,
    type: [Array, Boolean, String]
  },
  slideEffect: {
    type: String,
    default: DEFAULT_CONFIG.slideEffect,
    validator(value) {
      return SLIDE_EFFECTS.includes(value);
    }
  }
};
var Carousel = defineComponent({
  name: "VueCarousel",
  props: carouselProps,
  emits: [
    "init",
    "drag",
    "slide-start",
    "loop",
    "update:modelValue",
    "slide-end",
    "before-init",
    "slide-registered",
    "slide-unregistered"
  ],
  setup(props, { slots, emit, expose }) {
    var _a;
    const slideRegistry = createSlideRegistry(emit);
    const slides = slideRegistry.getSlides();
    const slidesCount = computed(() => slides.length);
    const root = ref(null);
    const viewport = ref(null);
    const slideSize = ref(0);
    const fallbackConfig = computed(() => Object.assign(Object.assign(Object.assign({}, DEFAULT_CONFIG), except(props, ["breakpoints", "modelValue"])), { i18n: Object.assign(Object.assign({}, DEFAULT_CONFIG.i18n), props.i18n) }));
    const config = shallowReactive(Object.assign({}, fallbackConfig.value));
    const currentSlideIndex = ref((_a = props.modelValue) !== null && _a !== void 0 ? _a : 0);
    const activeSlideIndex = ref(currentSlideIndex.value);
    watch(currentSlideIndex, (val) => activeSlideIndex.value = val);
    const prevSlideIndex = ref(0);
    const middleSlideIndex = computed(() => Math.ceil((slidesCount.value - 1) / 2));
    const maxSlideIndex = computed(() => {
      return getMaxSlideIndex({ config, slidesCount: slidesCount.value });
    });
    const minSlideIndex = computed(() => {
      return getMinSlideIndex({ config, slidesCount: slidesCount.value });
    });
    let autoplayTimer = null;
    let transitionTimer = null;
    let resizeObserver = null;
    const effectiveSlideSize = computed(() => slideSize.value + config.gap);
    const normalizedDir = computed(() => {
      const dir = config.dir || "ltr";
      return dir in DIR_MAP ? DIR_MAP[dir] : dir;
    });
    const isReversed = computed(() => ["rtl", "btt"].includes(normalizedDir.value));
    const isVertical = computed(() => ["ttb", "btt"].includes(normalizedDir.value));
    function updateBreakpointsConfig() {
      var _a2;
      if (!mounted.value) {
        return;
      }
      const widthSource = (fallbackConfig.value.breakpointMode === "carousel" ? (_a2 = root.value) === null || _a2 === void 0 ? void 0 : _a2.getBoundingClientRect().width : typeof window !== "undefined" ? window.innerWidth : 0) || 0;
      const breakpointsArray = Object.keys(props.breakpoints || {}).map((key) => Number(key)).sort((a, b) => +b - +a);
      const newConfig = {};
      breakpointsArray.some((breakpoint) => {
        if (widthSource >= breakpoint) {
          Object.assign(newConfig, props.breakpoints[breakpoint]);
          if (newConfig.i18n) {
            Object.assign(newConfig.i18n, fallbackConfig.value.i18n, props.breakpoints[breakpoint].i18n);
          }
          return true;
        }
        return false;
      });
      Object.assign(config, fallbackConfig.value, newConfig);
    }
    const handleResize = throttle(() => {
      updateBreakpointsConfig();
      updateSlidesData();
      updateSlideSize();
    });
    const totalGap = computed(() => (config.itemsToShow - 1) * config.gap);
    const transformElements = shallowReactive(/* @__PURE__ */ new Set());
    function updateSlideSize() {
      if (!viewport.value)
        return;
      let multiplierWidth = 1;
      transformElements.forEach((el) => {
        const transformArr = getTransformValues(el);
        if (transformArr.length === 6) {
          multiplierWidth *= transformArr[0];
        }
      });
      if (isVertical.value) {
        if (config.height !== "auto") {
          const height = typeof config.height === "string" && isNaN(parseInt(config.height)) ? viewport.value.getBoundingClientRect().height : parseInt(config.height);
          slideSize.value = (height - totalGap.value) / config.itemsToShow;
        }
      } else {
        const width = viewport.value.getBoundingClientRect().width;
        slideSize.value = (width / multiplierWidth - totalGap.value) / config.itemsToShow;
      }
    }
    function updateSlidesData() {
      if (!config.wrapAround && slidesCount.value > 0) {
        currentSlideIndex.value = getNumberInRange({
          val: currentSlideIndex.value,
          max: maxSlideIndex.value,
          min: minSlideIndex.value
        });
      }
      config.itemsToShow = getNumberInRange({
        val: config.itemsToShow,
        max: slidesCount.value,
        min: 1
      });
    }
    const ignoreAnimations = computed(() => {
      if (typeof props.ignoreAnimations === "string") {
        return props.ignoreAnimations.split(",");
      } else if (Array.isArray(props.ignoreAnimations)) {
        return props.ignoreAnimations;
      } else if (!props.ignoreAnimations) {
        return [];
      }
      return false;
    });
    watchEffect(() => updateSlidesData());
    watchEffect(() => {
      updateSlideSize();
    });
    let animationInterval;
    const setAnimationInterval = (event) => {
      const target = event.target;
      if (!(target === null || target === void 0 ? void 0 : target.contains(root.value)) || Array.isArray(ignoreAnimations.value) && ignoreAnimations.value.includes(event.animationName)) {
        return;
      }
      transformElements.add(target);
      if (!animationInterval) {
        const stepAnimation = () => {
          animationInterval = requestAnimationFrame(() => {
            updateSlideSize();
            stepAnimation();
          });
        };
        stepAnimation();
      }
    };
    const finishAnimation = (event) => {
      const target = event.target;
      if (target) {
        transformElements.delete(target);
      }
      if (animationInterval && transformElements.size === 0) {
        cancelAnimationFrame(animationInterval);
        updateSlideSize();
      }
    };
    const mounted = ref(false);
    if (typeof document !== "undefined") {
      watchEffect(() => {
        if (mounted.value && ignoreAnimations.value !== false) {
          document.addEventListener("animationstart", setAnimationInterval);
          document.addEventListener("animationend", finishAnimation);
        } else {
          document.removeEventListener("animationstart", setAnimationInterval);
          document.removeEventListener("animationend", finishAnimation);
        }
      });
    }
    onMounted(() => {
      mounted.value = true;
      updateBreakpointsConfig();
      initAutoplay();
      if (root.value) {
        resizeObserver = new ResizeObserver(handleResize);
        resizeObserver.observe(root.value);
      }
      emit("init");
    });
    onBeforeUnmount(() => {
      mounted.value = false;
      slideRegistry.cleanup();
      if (transitionTimer) {
        clearTimeout(transitionTimer);
      }
      if (animationInterval) {
        cancelAnimationFrame(animationInterval);
      }
      if (autoplayTimer) {
        clearInterval(autoplayTimer);
      }
      if (resizeObserver) {
        resizeObserver.disconnect();
        resizeObserver = null;
      }
      if (typeof document !== "undefined") {
        handleBlur();
      }
      if (root.value) {
        root.value.removeEventListener("transitionend", updateSlideSize);
        root.value.removeEventListener("animationiteration", updateSlideSize);
      }
    });
    let isTouch = false;
    const startPosition = { x: 0, y: 0 };
    const dragged = reactive({ x: 0, y: 0 });
    const isHover = ref(false);
    const isDragging = ref(false);
    const handleMouseEnter = () => {
      isHover.value = true;
    };
    const handleMouseLeave = () => {
      isHover.value = false;
    };
    const handleArrowKeys = throttle((event) => {
      if (event.ctrlKey)
        return;
      switch (event.key) {
        case "ArrowLeft":
        case "ArrowUp":
          if (isVertical.value === event.key.endsWith("Up")) {
            if (isReversed.value) {
              nav.next(true);
            } else {
              nav.prev(true);
            }
          }
          break;
        case "ArrowRight":
        case "ArrowDown":
          if (isVertical.value === event.key.endsWith("Down")) {
            if (isReversed.value) {
              nav.prev(true);
            } else {
              nav.next(true);
            }
          }
          break;
      }
    }, 200);
    const handleFocus = () => {
      document.addEventListener("keydown", handleArrowKeys);
    };
    const handleBlur = () => {
      document.removeEventListener("keydown", handleArrowKeys);
    };
    function handleDragStart(event) {
      const targetTagName = event.target.tagName;
      if (["INPUT", "TEXTAREA", "SELECT"].includes(targetTagName) || isSliding.value) {
        return;
      }
      isTouch = event.type === "touchstart";
      if (!isTouch) {
        event.preventDefault();
        if (event.button !== 0) {
          return;
        }
      }
      startPosition.x = "touches" in event ? event.touches[0].clientX : event.clientX;
      startPosition.y = "touches" in event ? event.touches[0].clientY : event.clientY;
      const moveEvent = isTouch ? "touchmove" : "mousemove";
      const endEvent = isTouch ? "touchend" : "mouseup";
      document.addEventListener(moveEvent, handleDragging, { passive: false });
      document.addEventListener(endEvent, handleDragEnd, { passive: true });
    }
    const handleDragging = throttle((event) => {
      isDragging.value = true;
      const currentX = "touches" in event ? event.touches[0].clientX : event.clientX;
      const currentY = "touches" in event ? event.touches[0].clientY : event.clientY;
      dragged.x = currentX - startPosition.x;
      dragged.y = currentY - startPosition.y;
      const draggedSlides = getDraggedSlidesCount({
        isVertical: isVertical.value,
        isReversed: isReversed.value,
        dragged,
        effectiveSlideSize: effectiveSlideSize.value
      });
      activeSlideIndex.value = config.wrapAround ? currentSlideIndex.value + draggedSlides : getNumberInRange({
        val: currentSlideIndex.value + draggedSlides,
        max: maxSlideIndex.value,
        min: minSlideIndex.value
      });
      emit("drag", { deltaX: dragged.x, deltaY: dragged.y });
    });
    function handleDragEnd() {
      handleDragging.cancel();
      if (activeSlideIndex.value !== currentSlideIndex.value && !isTouch) {
        const preventClick = (e) => {
          e.preventDefault();
          window.removeEventListener("click", preventClick);
        };
        window.addEventListener("click", preventClick);
      }
      slideTo(activeSlideIndex.value);
      dragged.x = 0;
      dragged.y = 0;
      isDragging.value = false;
      const moveEvent = isTouch ? "touchmove" : "mousemove";
      const endEvent = isTouch ? "touchend" : "mouseup";
      document.removeEventListener(moveEvent, handleDragging);
      document.removeEventListener(endEvent, handleDragEnd);
    }
    function initAutoplay() {
      if (!config.autoplay || config.autoplay <= 0) {
        return;
      }
      autoplayTimer = setInterval(() => {
        if (config.pauseAutoplayOnHover && isHover.value) {
          return;
        }
        next();
      }, config.autoplay);
    }
    function stopAutoplay() {
      if (autoplayTimer) {
        clearInterval(autoplayTimer);
        autoplayTimer = null;
      }
    }
    function resetAutoplay() {
      stopAutoplay();
      initAutoplay();
    }
    const isSliding = ref(false);
    function slideTo(slideIndex, skipTransition = false) {
      if (!skipTransition && isSliding.value) {
        return;
      }
      let targetIndex = slideIndex;
      let mappedIndex = slideIndex;
      prevSlideIndex.value = currentSlideIndex.value;
      if (!config.wrapAround) {
        targetIndex = getNumberInRange({
          val: targetIndex,
          max: maxSlideIndex.value,
          min: minSlideIndex.value
        });
      } else {
        mappedIndex = mapNumberToRange({
          val: targetIndex,
          max: maxSlideIndex.value,
          min: 0
        });
      }
      emit("slide-start", {
        slidingToIndex: slideIndex,
        currentSlideIndex: currentSlideIndex.value,
        prevSlideIndex: prevSlideIndex.value,
        slidesCount: slidesCount.value
      });
      stopAutoplay();
      isSliding.value = true;
      currentSlideIndex.value = targetIndex;
      if (mappedIndex !== targetIndex) {
        modelWatcher.pause();
      }
      emit("update:modelValue", mappedIndex);
      const transitionCallback = () => {
        if (config.wrapAround) {
          if (mappedIndex !== targetIndex) {
            modelWatcher.resume();
            currentSlideIndex.value = mappedIndex;
            emit("loop", {
              currentSlideIndex: currentSlideIndex.value,
              slidingToIndex: slideIndex
            });
          }
        }
        emit("slide-end", {
          currentSlideIndex: currentSlideIndex.value,
          prevSlideIndex: prevSlideIndex.value,
          slidesCount: slidesCount.value
        });
        isSliding.value = false;
        resetAutoplay();
      };
      transitionTimer = setTimeout(transitionCallback, config.transition);
    }
    function next(skipTransition = false) {
      slideTo(currentSlideIndex.value + config.itemsToScroll, skipTransition);
    }
    function prev(skipTransition = false) {
      slideTo(currentSlideIndex.value - config.itemsToScroll, skipTransition);
    }
    const nav = { slideTo, next, prev };
    const scrolledIndex = computed(() => getScrolledIndex({
      config,
      currentSlide: currentSlideIndex.value,
      slidesCount: slidesCount.value
    }));
    const provided = reactive({
      config,
      slidesCount,
      viewport,
      slides,
      scrolledIndex,
      currentSlide: currentSlideIndex,
      activeSlide: activeSlideIndex,
      maxSlide: maxSlideIndex,
      minSlide: minSlideIndex,
      slideSize,
      isVertical,
      normalizedDir,
      nav,
      isSliding,
      slideRegistry
    });
    provide(injectCarousel, provided);
    provide("config", config);
    provide("slidesCount", slidesCount);
    provide("currentSlide", currentSlideIndex);
    provide("maxSlide", maxSlideIndex);
    provide("minSlide", minSlideIndex);
    provide("slideSize", slideSize);
    provide("isVertical", isVertical);
    provide("normalizeDir", normalizedDir);
    provide("nav", nav);
    provide("isSliding", isSliding);
    function restartCarousel() {
      updateBreakpointsConfig();
      updateSlidesData();
      updateSlideSize();
      resetAutoplay();
    }
    watch(() => [fallbackConfig.value, props.breakpoints], () => updateBreakpointsConfig(), { deep: true });
    watch(() => props.autoplay, () => resetAutoplay());
    const modelWatcher = watch(() => props.modelValue, (val) => {
      if (val === currentSlideIndex.value) {
        return;
      }
      slideTo(Number(val), true);
    });
    emit("before-init");
    const data = reactive({
      config,
      slidesCount,
      slideSize,
      currentSlide: currentSlideIndex,
      maxSlide: maxSlideIndex,
      minSlide: minSlideIndex,
      middleSlide: middleSlideIndex
    });
    expose({
      updateBreakpointsConfig,
      updateSlidesData,
      updateSlideSize,
      restartCarousel,
      slideTo,
      next,
      prev,
      nav,
      data
    });
    const trackHeight = computed(() => {
      if (config.height === "auto") {
        if (isVertical.value && slideSize.value) {
          return `${slideSize.value * config.itemsToShow + totalGap.value}px`;
        }
        return void 0;
      }
      if (typeof config.height === "number" || parseFloat(config.height).toString() === config.height) {
        return `${config.height}px`;
      } else {
        return config.height;
      }
    });
    const clonedSlidesCount = computed(() => {
      if (!config.wrapAround) {
        return { before: 0, after: 0 };
      }
      const slidesToClone = Math.ceil(config.itemsToShow + (config.itemsToScroll - 1));
      const before = slidesToClone - activeSlideIndex.value;
      const after = slidesToClone - (slidesCount.value - (activeSlideIndex.value + 1));
      return {
        before: Math.max(0, before),
        after: Math.max(0, after)
      };
    });
    const clonedSlidesOffset = computed(() => clonedSlidesCount.value.before * effectiveSlideSize.value * -1);
    const trackTransform = computed(() => {
      const directionMultiplier = isReversed.value ? 1 : -1;
      const translateAxis = isVertical.value ? "Y" : "X";
      const scrolledOffset = scrolledIndex.value * effectiveSlideSize.value * directionMultiplier;
      const dragOffset = isVertical.value ? dragged.y : dragged.x;
      const totalOffset = scrolledOffset + dragOffset;
      return `translate${translateAxis}(${totalOffset}px)`;
    });
    const trackStyle = computed(() => ({
      transform: config.slideEffect === "slide" ? trackTransform.value : void 0,
      gap: config.gap > 0 ? `${config.gap}px` : void 0,
      "--vc-trk-transition-duration": isSliding.value ? `${config.transition}ms` : void 0,
      "--vc-trk-height": trackHeight.value,
      "--vc-trk-cloned-offset": `${clonedSlidesOffset.value}px`
    }));
    return () => {
      var _a2;
      const slotSlides = slots.default || slots.slides;
      const outputSlides = (slotSlides === null || slotSlides === void 0 ? void 0 : slotSlides(data)) || [];
      const { before, after } = clonedSlidesCount.value;
      const slidesBefore = createCloneSlides({
        slides,
        position: "before",
        toShow: before
      });
      const slidesAfter = createCloneSlides({
        slides,
        position: "after",
        toShow: after
      });
      const output = [...slidesBefore, ...outputSlides, ...slidesAfter];
      if (!config.enabled || !output.length) {
        return h("section", {
          ref: root,
          class: ["carousel", "is-disabled"]
        }, output);
      }
      const addonsElements = ((_a2 = slots.addons) === null || _a2 === void 0 ? void 0 : _a2.call(slots, data)) || [];
      const trackEl = h("ol", {
        class: "carousel__track",
        style: trackStyle.value,
        onMousedownCapture: config.mouseDrag ? handleDragStart : null,
        onTouchstartPassiveCapture: config.touchDrag ? handleDragStart : null
      }, output);
      const viewPortEl = h("div", { class: "carousel__viewport", ref: viewport }, trackEl);
      return h("section", {
        ref: root,
        class: [
          "carousel",
          `is-${normalizedDir.value}`,
          `is-effect-${config.slideEffect}`,
          {
            "is-vertical": isVertical.value,
            "is-sliding": isSliding.value,
            "is-dragging": isDragging.value,
            "is-hover": isHover.value
          }
        ],
        dir: normalizedDir.value,
        "aria-label": config.i18n["ariaGallery"],
        tabindex: "0",
        onFocus: handleFocus,
        onBlur: handleBlur,
        onMouseenter: handleMouseEnter,
        onMouseleave: handleMouseLeave
      }, [viewPortEl, addonsElements, h(ARIA)]);
    };
  }
});
var IconName;
(function(IconName2) {
  IconName2["arrowUp"] = "arrowUp";
  IconName2["arrowDown"] = "arrowDown";
  IconName2["arrowRight"] = "arrowRight";
  IconName2["arrowLeft"] = "arrowLeft";
})(IconName || (IconName = {}));
function isIconName(candidate) {
  return candidate in IconName;
}
var iconI18n = (name) => `icon${name.charAt(0).toUpperCase() + name.slice(1)}`;
var validateIconName = (value) => {
  return value && isIconName(value);
};
var icons = {
  arrowUp: "M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z",
  arrowDown: "M7.41 8.59L12 13.17l4.59-4.58L18 10l-6 6-6-6 1.41-1.41z",
  arrowRight: "M8.59 16.59L13.17 12 8.59 7.41 10 6l6 6-6 6-1.41-1.41z",
  arrowLeft: "M15.41 16.59L10.83 12l4.58-4.59L14 6l-6 6 6 6 1.41-1.41z"
};
var Icon = defineComponent({
  props: {
    name: {
      type: String,
      required: true,
      validator: validateIconName
    },
    title: {
      type: String,
      default: (props) => props.name ? DEFAULT_CONFIG.i18n[iconI18n(props.name)] : ""
    }
  },
  setup(props) {
    const carousel = inject(injectCarousel, null);
    return () => {
      const iconName = props.name;
      if (!iconName || !validateIconName(iconName))
        return;
      const path = icons[iconName];
      const pathEl = h("path", { d: path });
      const iconTitle = (carousel === null || carousel === void 0 ? void 0 : carousel.config.i18n[iconI18n(iconName)]) || props.title;
      const titleEl = h("title", iconTitle);
      return h("svg", {
        class: "carousel__icon",
        viewBox: "0 0 24 24",
        role: "img",
        "aria-label": iconTitle
      }, [titleEl, pathEl]);
    };
  }
});
var Navigation = defineComponent({
  name: "CarouselNavigation",
  inheritAttrs: false,
  setup(props, { slots, attrs }) {
    const carousel = inject(injectCarousel);
    if (!carousel) {
      return () => "";
    }
    const { next: slotNext, prev: slotPrev } = slots;
    const getPrevIcon = () => {
      const directionIcons = {
        ltr: "arrowLeft",
        rtl: "arrowRight",
        ttb: "arrowUp",
        btt: "arrowDown"
      };
      return directionIcons[carousel.normalizedDir];
    };
    const getNextIcon = () => {
      const directionIcons = {
        ltr: "arrowRight",
        rtl: "arrowLeft",
        ttb: "arrowDown",
        btt: "arrowUp"
      };
      return directionIcons[carousel.normalizedDir];
    };
    const prevDisabled = computed(() => !carousel.config.wrapAround && carousel.currentSlide <= carousel.minSlide);
    const nextDisabled = computed(() => !carousel.config.wrapAround && carousel.currentSlide >= carousel.maxSlide);
    return () => {
      const { i18n } = carousel.config;
      const prevButton = h("button", Object.assign(Object.assign({ type: "button", disabled: prevDisabled.value, "aria-label": i18n["ariaPreviousSlide"], title: i18n["ariaPreviousSlide"], onClick: carousel.nav.prev }, attrs), { class: [
        "carousel__prev",
        { "carousel__prev--disabled": prevDisabled.value },
        attrs.class
      ] }), (slotPrev === null || slotPrev === void 0 ? void 0 : slotPrev()) || h(Icon, { name: getPrevIcon() }));
      const nextButton = h("button", Object.assign(Object.assign({ type: "button", disabled: nextDisabled.value, "aria-label": i18n["ariaNextSlide"], title: i18n["ariaNextSlide"], onClick: carousel.nav.next }, attrs), { class: [
        "carousel__next",
        { "carousel__next--disabled": nextDisabled.value },
        attrs.class
      ] }), (slotNext === null || slotNext === void 0 ? void 0 : slotNext()) || h(Icon, { name: getNextIcon() }));
      return [prevButton, nextButton];
    };
  }
});
var Pagination = defineComponent({
  name: "CarouselPagination",
  props: {
    disableOnClick: {
      type: Boolean
    },
    paginateByItemsToShow: {
      type: Boolean
    }
  },
  setup(props) {
    const carousel = inject(injectCarousel);
    if (!carousel) {
      return () => "";
    }
    const offset = computed(() => calculateOffset(carousel.config.snapAlign, carousel.config.itemsToShow));
    const isPaginated = computed(() => props.paginateByItemsToShow && carousel.config.itemsToShow > 1);
    const currentPage = computed(() => Math.ceil((carousel.activeSlide - offset.value) / carousel.config.itemsToShow));
    const pageCount = computed(() => Math.ceil(carousel.slidesCount / carousel.config.itemsToShow));
    const isActive = (slide) => mapNumberToRange(isPaginated.value ? {
      val: currentPage.value,
      max: pageCount.value - 1,
      min: 0
    } : {
      val: carousel.activeSlide,
      max: carousel.maxSlide,
      min: carousel.minSlide
    }) === slide;
    return () => {
      var _a, _b;
      const children = [];
      for (let slide = isPaginated.value ? 0 : carousel.minSlide; slide <= (isPaginated.value ? pageCount.value - 1 : carousel.maxSlide); slide++) {
        const buttonLabel = i18nFormatter(carousel.config.i18n[isPaginated.value ? "ariaNavigateToPage" : "ariaNavigateToSlide"], {
          slideNumber: slide + 1
        });
        const active = isActive(slide);
        const button = h("button", {
          type: "button",
          class: {
            "carousel__pagination-button": true,
            "carousel__pagination-button--active": active
          },
          "aria-label": buttonLabel,
          "aria-pressed": active,
          "aria-controls": (_b = (_a = carousel.slides[slide]) === null || _a === void 0 ? void 0 : _a.exposed) === null || _b === void 0 ? void 0 : _b.id,
          title: buttonLabel,
          disabled: props.disableOnClick,
          onClick: () => carousel.nav.slideTo(isPaginated.value ? slide * carousel.config.itemsToShow + offset.value : slide)
        });
        const item = h("li", { class: "carousel__pagination-item", key: slide }, button);
        children.push(item);
      }
      return h("ol", { class: "carousel__pagination" }, children);
    };
  }
});
var Slide = defineComponent({
  name: "CarouselSlide",
  props: {
    isClone: {
      type: Boolean,
      default: false
    },
    id: {
      type: String,
      default: (props) => props.isClone ? void 0 : useId()
    },
    index: {
      type: Number,
      default: void 0
    }
  },
  setup(props, { slots, expose }) {
    const carousel = inject(injectCarousel);
    provide(injectCarousel, void 0);
    if (!carousel) {
      return () => "";
    }
    const currentIndex = ref(props.index);
    const setIndex = (newIndex) => {
      currentIndex.value = newIndex;
    };
    expose({
      id: props.id,
      setIndex
    });
    const isActive = computed(() => currentIndex.value === carousel.activeSlide);
    const isPrev = computed(() => currentIndex.value === carousel.activeSlide - 1);
    const isNext = computed(() => currentIndex.value === carousel.activeSlide + 1);
    const isVisible = computed(() => currentIndex.value >= Math.floor(carousel.scrolledIndex) && currentIndex.value < Math.ceil(carousel.scrolledIndex) + carousel.config.itemsToShow);
    const slideStyle = computed(() => {
      const dimension = carousel.config.gap > 0 && carousel.config.itemsToShow > 1 ? `calc(${100 / carousel.config.itemsToShow}% - ${carousel.config.gap * (carousel.config.itemsToShow - 1) / carousel.config.itemsToShow}px)` : `${100 / carousel.config.itemsToShow}%`;
      return carousel.isVertical ? { height: dimension } : { width: dimension };
    });
    const instance = getCurrentInstance();
    carousel.slideRegistry.registerSlide(instance, props.index);
    onUnmounted(() => {
      carousel.slideRegistry.unregisterSlide(instance);
    });
    if (props.isClone) {
      onMounted(() => {
        disableChildrenTabbing(instance.vnode);
      });
      onUpdated(() => {
        disableChildrenTabbing(instance.vnode);
      });
    }
    return () => {
      var _a, _b;
      if (!carousel.config.enabled) {
        return (_a = slots.default) === null || _a === void 0 ? void 0 : _a.call(slots);
      }
      return h("li", {
        style: slideStyle.value,
        class: {
          carousel__slide: true,
          "carousel__slide--clone": props.isClone,
          "carousel__slide--visible": isVisible.value,
          "carousel__slide--active": isActive.value,
          "carousel__slide--prev": isPrev.value,
          "carousel__slide--next": isNext.value,
          "carousel__slide--sliding": carousel.isSliding
        },
        onFocusin: () => {
          if (carousel.viewport) {
            carousel.viewport.scrollLeft = 0;
          }
          carousel.nav.slideTo(currentIndex.value);
        },
        id: props.isClone ? void 0 : props.id,
        "aria-hidden": props.isClone || void 0
      }, (_b = slots.default) === null || _b === void 0 ? void 0 : _b.call(slots, {
        isActive: isActive.value,
        isClone: props.isClone,
        isPrev: isPrev.value,
        isNext: isNext.value,
        isSliding: carousel.isSliding,
        isVisible: isVisible.value
      }));
    };
  }
});
export {
  BREAKPOINT_MODE_OPTIONS,
  Carousel,
  DEFAULT_CONFIG,
  DIR_MAP,
  DIR_OPTIONS,
  I18N_DEFAULT_CONFIG,
  Icon,
  NORMALIZED_DIR_OPTIONS,
  Navigation,
  Pagination,
  SLIDE_EFFECTS,
  SNAP_ALIGN_OPTIONS,
  Slide,
  createSlideRegistry,
  icons,
  injectCarousel
};
/*! Bundled license information:

vue3-carousel/dist/carousel.mjs:
  (**
   * Vue 3 Carousel 0.12.0
   * (c) 2024
   * @license MIT
   *)
*/
//# sourceMappingURL=vue3-carousel.js.map
